## Chapters

Ch-1: Getting Started
Ch-2: Creating Issues
Ch-3: Viewing Issues
Ch-4: Updating Issues
Ch-5: Deleting Issues
Ch-6: Authentication
Ch-7: Assigning Issues to Users
Ch-8: Filtering, Sorting, and Pagination
Ch-9: Dashboard
Ch-10: Going to Production

## Ch-1: Getting Started

### - How to start and finish a Project

Start from Core feature ahead to Advance feature

## Tables

| CORE (Must have)   | ADVANCED (Nice to have) |
| :----------------- | :---------------------- |
| Createing an issue | User authentication     |
| Viewing issues     | Assigning issues        |
| Updating an issues | Sorting issues          |
| Deleting an issues | Filtering issues        |
|                    | Pagination              |
|                    | Dashboard               |

**Key: Focus one feature at a time. Goal is not for "perfect" solution.**<br>
**Goal is not for "perfect" solution. Make it work first. Then Improve it step by step (Refactoring)**

### - Installation

```jsx
npx create-next-app@latest
```

Manual Installation

```jsx
npm install next@latest react@latest react-dom@latest
```

### - Build the navbar

Install [react icon](https://react-icons.github.io/react-icons)

```bash
npm i react-icons
```

```jsx
// layout.tsx (<main>{children}</main>)
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import NavBar from "./NavBar";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode,
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <NavBar />
        <main>{children}</main>
      </body>
    </html>
  );
}

// NavBar.tsx  (AiFillBug icon, Dynamic Menu from array of object)
import Link from "next/link";
import { AiFillBug } from "react-icons/ai";

const NavBar = () => {
  const links = [
    { label: "Dashboard", href: "/" },
    { label: "Issues", href: "/issues" },
  ];
  return (
    <nav className="flex space-x-6 border-b px-5 mb-5 h-14 items-center">
      <Link href="/">
        <AiFillBug />
      </Link>
      <ul className="flex space-x-6">
        {links.map((link) => (
          <Link
            key={link.href}
            className="text-zinc-500 hover:text-zinc-800 transition-colors"
            href={link.href}
          >
            {link.label}
          </Link>
        ))}
      </ul>
    </nav>
  );
};
```

### - Styling the Active Link (Navbar.tsx)

Conditional CSS rendering & Classnames:
Code will be cleaner and what classes will render under what condition

```bash
npm i classnames@2.3.2
```

```jsx
// Conditional CSS rendering
<Link
  key={link.href}
  className={`${
    link.href === currentPath ? "text-zinc-900" : "text-zinc-500"
  } hover:text-zinc-800 transition-colors`}
  href={link.href}
>
  {link.label}
</Link>

// Using ClassName (Code is cleaner)
<Link
key={link.href}
className={classNames({
    "text-zinc-900": link.href === currentPath,
    "text-zinc-500": link.href !== currentPath,
    "hover:text-zinc-800 transition-colors": true,
})}
href={link.href}
>
```

## Ch-2: Creating Issues

### - Install mysql

Wamp for testing

### - Setting Up Prisma

```bash
npm i prisma
```

Initializing Prisma - npx create folder

```bash
npx prisma init
```

Now in prisma/schema.prisma (datasource>provider to mysql)

```jsx
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

.env file [Connection String Format](https://prnt.sc/Z1H-zDfYb5b1) For MySql Database

```jsx
DATABASE_URL = "mysql://root:@localhost:3306/issue-tracker"  ----Connection String no ";" @end----
```

### - Creating the issue model

- Just create simple model. Not assignin issue to user so no relationship

```jsx
// schema.prisma (Model: Pascale Case and singular name)
model Issue {
  id          Int      @id @default(autoincrement())
  title       String   @db.VarChar(255)
  description String   @db.Text
  status      Status   @default(OPEN)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

enum Status {
  OPEN
  IN_PROGRESS
  CLOSED
}
```

```bash
npx prisma format
npx prisma migrate dev
```

### - Building an API

```bash
npm i zod@3.22.2
```

Best Practice: Make sure create only one instance of [Prisma Client](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices)<br>

```jsx
// prisma/client.ts (Only Once)
import { PrismaClient } from "@prisma/client";

const prismaClientSingleton = () => {
  return new PrismaClient();
};

declare global {
  var prismaGlobal: undefined | ReturnType<typeof prismaClientSingleton>;
}

const prisma = globalThis.prismaGlobal ?? prismaClientSingleton();

export default prisma;

if (process.env.NODE_ENV !== "production") globalThis.prismaGlobal = prisma;

```

**Make sure async - await is properly placed when building API**

```jsx
// app/api/issues/route.ts
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import prisma from "@/prisma/client";

const createIssueSchema = z.object({
  title: z.string().min(1).max(255),
  description: z.string().min(1),
});
export async function POST(request: NextRequest) {
  const body = await request.json();

  const validation = createIssueSchema.safeParse(body);

  if (!validation.success)
    return NextResponse.json(validation.error.errors, { status: 400 });

  const newIssue = await prisma.issue.create({
    data: {
      title: body.title,
      description: body.description,
    },
  });

  return NextResponse.json(newIssue, { status: 201 });
}
```

### - Setting up Radix UI

[radix-ui.com](https://www.radix-ui.com)

1. Install Radix Themes

```bash
npm install @radix-ui/themes
```

2. Import the CSS root app/layout.ts

```jsx
// app/layout.ts
import "@radix-ui/themes/styles.css";
```

3. Add the Theme component - root app/layout.ts

```jsx
// app/layout.ts
import { Theme } from "@radix-ui/themes";

export default function () {
  return (
    <html>
      <body>
        <Theme>
          <MyApp />
        </Theme>
      </body>
    </html>
  );
}

// issues/page.ts
import React from "react";
import { Button } from "@radix-ui/themes";

const IssuesPage = () => {
  return (
    <div>
      <Button>New Issue</Button>
    </div>
  );
};
```

### - Build the New Issue Page (Look and feel of the page not function)

```jsx
// issues/page.ts
<Button>
  <Link href="/issues/new">New Issue</Link>
</Button>
```

This page has form handling with client "use client"

```jsx
// issues/new/page.ts
"use client";
import { Button, TextArea, TextField } from "@radix-ui/themes";
import React from "react";

const NewIssuePage = () => {
  return (
    <div className="max-w-xl space-y-3">
      <TextField.Root placeholder="Title" />
      <TextArea placeholder="Description" />
      <Button>Submit New Issue</Button>
    </div>
  );
};
```

### - Customizing Radix UI Theme

< ThemePanel: [See and customized](https://prnt.sc/p4TeRHtTCoU9)

```jsx
// app/layout.ts
return (
  <html lang="en">
    <body className={inter.className}>
      <Theme accentColor="violet">
        <NavBar />
        <main className="p-5">{children}</main>
        <ThemePanel />
      </Theme>
    </body>
  </html>
);
```

**Change font: Inter font is not applying here because of Radix [Typographoy](https://www.radix-ui.com/themes/docs/theme/typography)**
You can keep css in globals.css/theme-config.css, add this syntax !important;

```jsx
import "@radix-ui/themes/styles.css";
import "./theme-config.css";

import { Inter } from "next/font/google";
import { Theme, ThemePanel } from "@radix-ui/themes";

const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
});

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode,
}>) {
  return (
    <html lang="en">
      <body className={inter.variable}>
        <Theme accentColor="violet">
          <NavBar />
          <main className="p-5 radix-themes">{children}</main>
        </Theme>
      </body>
    </html>
  );
}

// globals.css ( !important is urgent )
.radix-themes {
  --default-font-family: var(--font-inter) !important;
}
```

### - Adding a Markdown Editor

[React Simplemde Editor](https://www.npmjs.com/package/react-simplemde-editor)
Install

```bash
npm install --save react-simplemde-editor easymde
```

```jsx
// issues/new/page.tsx (Use SimpleMDE instade of Textarea)
"use client";
import { Button, TextArea, TextField } from "@radix-ui/themes";
import SimpleMDE from "react-simplemde-editor"; // added 1
import "easymde/dist/easymde.min.css"; // added 2

const NewIssuePage = () => {
  return (
    <div className="max-w-xl space-y-3">
      <TextField.Root placeholder="Title" />
      <SimpleMDE />
      <Button>Submit New Issue</Button>
    </div>
  );
};
```

### - Handling Form Submission (issues/new/page.tsx)

Install:
"axios": "^1.6.8",
"react-hook-form": "^7.51.3", (Hook form can not work with < SimpleMDE so use controller )

```jsx
// issues/new/page.tsx  (import { useRouter } from "next/navigation"; not next/router)
"use client";
import { Button, TextArea, TextField } from "@radix-ui/themes";
import SimpleMDE from "react-simplemde-editor";
import "easymde/dist/easymde.min.css";
import { useForm, Controller } from "react-hook-form";
import axios from "axios";
import { useRouter } from "next/navigation";

interface IssueForm {
  title: string;
  description: string;
}

const NewIssuePage = () => {
  const router = useRouter();
  const { register, control, handleSubmit } = useForm<IssueForm>();

  return (
    <form
      className="max-w-xl space-y-3"
      onSubmit={handleSubmit(async (data) => {
        await axios.post("/api/issues", data);
        router.push("/issues");
      })}
    >
      <TextField.Root placeholder="Title" {...register("title")} />
      <Controller
        name="description"
        control={control}
        render={({ field }) => (
          <SimpleMDE placeholder="Description" {...field} />
        )}
      />

      <Button type="submit">Submit New Issue</Button>
    </form>
  );
};
```

### - Handling Errors | Server side validaion (Server side - API)

- Server and Client both validation is must needed. First need to build Server side validation then Client side. Because If we build Client side validation then it will difficult to test server side validation.

```jsx
// issues/new/page.tsx
return (
  <div className="max-w-xl">
    {error && (
      <Callout.Root color="red" className="mb-3">
        <Callout.Text>{error}</Callout.Text>
      </Callout.Root>
    )}
    <form
      className="space-y-3"
      onSubmit={handleSubmit(async (data) => {
        try {
          await axios.post("/api/issues", data);
          router.push("/issues");
        } catch (error) {
          console.log(error); // debugge here
          setError("An unexpected error occurred.");
        }
      })}
    >
      <TextField.Root placeholder="Title" {...register("title")} />
      <Controller
        name="description"
        control={control}
        render={({ field }) => (
          <SimpleMDE placeholder="Description" {...field} />
        )}
      />

      <Button type="submit">Submit New Issue</Button>
    </form>
  </div>
);

// api/issues/page.tsx
const createIssueSchema = z.object({
  title: z.string().min(1, "Title is required.").max(255), // Added MSG
  description: z.string().min(1, "Description is required."),
});
export async function POST(request: NextRequest) {
  const body = await request.json();

  const validation = createIssueSchema.safeParse(body);

  if (!validation.success)
    return NextResponse.json(validation.error.format(), { status: 400 }); // Added .format()

  const newIssue = await prisma.issue.create({
    data: {
      title: body.title,
      description: body.description,
    },
  });

  return NextResponse.json(newIssue, { status: 201 });
}
```

### - Implement Client-Side Validation

1. Install [Resolvers](https://www.npmjs.com/package/@hookform/resolvers)
2. createIssueSchema object bring Out of api/issues/page.ts using refactor because we can not export other thing from a route.ts file to use it in issues/new/page.tsx. [Click](https://prnt.sc/DsgOQO1ikUc7)
3. Work on issues/new/page.tsx

```bash
npm i @hookform/resolvers
```

**Refactor createIssueSchema and move to new file. Because we can export this variable but route.ts only export GET, POST, PUT, DELETE**

```jsx
// api/issues/page.ts
import { z } from "zod";
import prisma from "@/prisma/client";

const createIssueSchema = z.object({
  title: z.string().min(1, "Title is required.").max(255),
  description: z.string().min(1, "Description is required."),
});

export async function POST(request: NextRequest) {
  const body = await request.json();
........

to----->

import prisma from "@/prisma/client";
import { createIssueSchema } from "../../validationSchema";

export async function POST(request: NextRequest) {
  const body = await request.json();

// ValidationSchema.ts
import { z } from "zod";

export const createIssueSchema = z.object({
  title: z.string().min(1, "Title is required.").max(255),
  description: z.string().min(1, "Description is required."),
});

// issues/new/page.tsx (need not create redundent interface we can grab type from zod interface)
"use client";
import { zodResolver } from "@hookform/resolvers/zod";
import { createIssueSchema } from "@/app/validationSchema";
import { z } from "zod";

type IssueForm = z.infer<typeof createIssueSchema>;

const NewIssuePage = () => {
  const router = useRouter();
  const {
    register,
    control,
    handleSubmit,
    formState: { errors },
  } = useForm<IssueForm>({
    resolver: zodResolver(createIssueSchema),
  });
  const [error, setError] = useState("");

  return (
    <div className="max-w-xl">
      {error && (
        <Callout.Root color="red" className="mb-3">
          <Callout.Text>{error}</Callout.Text>
        </Callout.Root>
      )}
      <form
        className="space-y-3"
        onSubmit={handleSubmit(async (data) => {
          try {
            await axios.post("/api/issues", data);
            router.push("/issues");
          } catch (error) {
            console.log(error);
            setError("An unexpected error occurred.");
          }
        })}
      >
        <TextField.Root placeholder="Title" {...register("title")} />
        {errors.title && (
          <Text color="red" as="p">
            {errors.title.message}
          </Text>
        )}
        <Controller
          name="description"
          control={control}
          render={({ field }) => (
            <SimpleMDE placeholder="Description" {...field} />
          )}
        />
        {errors.description && (
          <Text color="red" as="p">
            {errors.description.message}
          </Text>
        )}
        <Button type="submit">Submit New Issue</Button>
      </form>
    </div>
  );
};
..........

```

### - Extractiong the ErrorMessage Component

- Create seperate component for displaying error message to make it consistant and well organized.
- NB: If a component is only need for a page then create it localy, If you want to reuse it different pages then create in /app/components/myCommponent.tsx

```jsx
// issues/new/page.tsx
<ErrorMessage>{errors.title?.message}</ErrorMessage>;

// app/components/ErrorMessage.tsx
import { Text } from "@radix-ui/themes";
import React, { PropsWithChildren } from "react";

const ErrorMessage = ({ children }: PropsWithChildren) => {
  return (
    <>
      {children && (
        <Text color="red" as="p">
          {children}
        </Text>
      )}
    </>
  );
};
```

### - Adding a Spinner (When submitting form)

[Google: Tailwind Elements Spinner](https://tw-elements.com/docs/standard/components/spinners/)

```jsx
// issues/new/page.tsx
const [isSubmitting, setSubmitting] = useState(false);
<Button type="submit">Submit New Issue {isSubmitting && <Spinner />}</Button>;
<form
  className="space-y-3"
  onSubmit={handleSubmit(async (data) => {
    try {
      setSubmitting(true);
      await axios.post("/api/issues", data);
      router.push("/issues");
    } catch (error) {
      // console.log(error);
      setSubmitting(false);
      setError("An unexpected error occurred.");
    }
  })}
>

// app/conponents/Spinner.tsx
import React from "react";

const Spinner = () => {
  return (
    <div
      className="inline-block h-4 w-4 animate-spin rounded-full border-2 border-solid border-current border-e-transparent align-[-0.125em] text-surface motion-reduce:animate-[spin_1.5s_linear_infinite] dark:text-white"
      role="status"
    >
      <span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">
        Loading...
      </span>
    </div>
  );
};
```

### - Code Organization: Refactoring (Inline function to outside function defination)

- onSubmit: just cut inline function and paste it
- Separation of Concerns: Separate a program into distinct modules each having a separate concern.
  If concerns are well separated, there are more opportunities for code reuse.
- Software Engineering is not Black and White. "This is the best practice! You should always do things this way!" Not like this

```jsx
// issues/new/page.tsx
import ErrorMessage from "@/app/components/ErrorMessage";

  const onSubmit = handleSubmit(async (data) => {
    try {
      setSubmitting(true);
      await axios.post("/api/issues", data);
      router.push("/issues");
    } catch (error) {
      // console.log(error);
      setSubmitting(false);
      setError("An unexpected error occurred.");
    }
  });

  return (
      <form className="space-y-3" onSubmit={onSubmit}>
        <TextField.Root placeholder="Title" {...register("title")} />
        <ErrorMessage>{errors.title?.message}</ErrorMessage>
        <Controller
          name="description"
          control={control}
          render={({ field }) => (
            <SimpleMDE placeholder="Description" {...field} />
          )}
        />
```

## Ch-3: Viewing Issues

### - Showing the Issues

```jsx
// issues/page.tsx
import prisma from "@/prisma/client";

const IssuesPage = async () => {
  const issues = await prisma.issue.findMany(); // One line fetch all data

  return (
    <div>
      <div className="mb-5">
        <Button>
          <Link href="/issues/new">New Issue</Link>
        </Button>
      </div>
      <Table.Root variant="surface">
        <Table.Header>
          <Table.Row>
            <Table.ColumnHeaderCell>Issue</Table.ColumnHeaderCell>
            <Table.ColumnHeaderCell className="hidden md:table-cell">
              Status
            </Table.ColumnHeaderCell>
            <Table.ColumnHeaderCell className="hidden md:table-cell">
              Created
            </Table.ColumnHeaderCell>
          </Table.Row>
        </Table.Header>
        <Table.Body>
          {issues.map((issue) => (
            <Table.Row key={issue.id}>
              <Table.Cell>
                {issue.title}
                <div className="md:hidden">{issue.status}</div>
              </Table.Cell>
              <Table.Cell className="hidden md:table-cell">
                {issue.status}
              </Table.Cell>
              <Table.Cell className="hidden md:table-cell">
                {issue.createdAt.toDateString()}
              </Table.Cell>
            </Table.Row>
          ))}
        </Table.Body>
      </Table.Root>
    </div>
  );
};
```

### - Building the Issue Status Badge

- You can grab any Prisma Model type/interface. [Click](https://prnt.sc/Fg-cvBJFqk04)
- Record is typescript concept using for key-value pair

```jsx
// issues/page.tsx
<IssueStatusBadge status={issue.status} />;

// IssueStatusBadge.tsx
import { Status } from "@prisma/client";
import { Badge } from "@radix-ui/themes";
import React from "react";

const statusMap: Record<
  Status,
  { label: string, color: "red" | "violet" | "green" }
> = {
  OPEN: { label: "Open", color: "red" },
  IN_PROGRESS: { label: "In Progress", color: "violet" },
  CLOSED: { label: "Closed", color: "green" },
};
const IssueStatusBadge = ({ status }: { status: Status }) => {
  return (
    <Badge color={statusMap[status].color}>{statusMap[status].label}</Badge>
  );
};
```

### - Adding Loading Skeletons

- use delay to watch loading skeletons properly.

```bash
npm i delay
```

```jsx
// in issues/page.tsx (before return)
await delay(2000);
```

- Use [React-Loading-Skeleton
  ](https://www.npmjs.com/package/react-loading-skeleton)

```bash
npm i react-loading-skeleton
```

```jsx
import Skeleton from "react-loading-skeleton";
import "react-loading-skeleton/dist/skeleton.css";
```

- add a new component IssueAction.tsx in local folder

```jsx
// issues/IssueActions.tsx
import { Button } from "@radix-ui/themes";
import Link from "next/link";
import React from "react";

const IssueActions = () => {
  return (
    <div className="mb-5">
      <Button>
        <Link href="/issues/new">New Issue</Link>
      </Button>
    </div>
  );
};

// issues/loading.tsx
import { Table } from "@radix-ui/themes";
import React from "react";
import IssueStatusBadge from "../components/IssueStatusBadge";
import Skeleton from "react-loading-skeleton";
import "react-loading-skeleton/dist/skeleton.css";
import IssueActions from "./IssueActions";

const LoadingIssuePage = () => {
  const issues = [1, 2, 3, 4, 5];
  return (
    <>
      <IssueActions />
      <Table.Root variant="surface">
        <Table.Header>
          <Table.Row>
            <Table.ColumnHeaderCell>Issue</Table.ColumnHeaderCell>
            <Table.ColumnHeaderCell className="hidden md:table-cell">
              Status
            </Table.ColumnHeaderCell>
            <Table.ColumnHeaderCell className="hidden md:table-cell">
              Created
            </Table.ColumnHeaderCell>
          </Table.Row>
        </Table.Header>
        <Table.Body>
          {issues.map((issue) => (
            <Table.Row key={issue}>
              <Table.Cell>
                <Skeleton />
                <div className="md:hidden">
                  <Skeleton />
                </div>
              </Table.Cell>
              <Table.Cell className="hidden md:table-cell">
                <Skeleton />
              </Table.Cell>
              <Table.Cell className="hidden md:table-cell">
                <Skeleton />
              </Table.Cell>
            </Table.Row>
          ))}
        </Table.Body>
      </Table.Root>
    </>
  );
};
```

**NB: page.tsx, loading.tsx, layout.tsx anything could be make client component, if it not contain any server function like prisma.model.findMany()**

### - Showing Issue Details - Only fetch data not style

- Add loading page both in new and [id] folder to get ride of skeleton loading of issues folder

```jsx
// issues/[id]/page.tsx
import prisma from "@/prisma/client";
import { notFound } from "next/navigation";

const SingleIssuePage = async ({
  params: { id },
}: {
  params: { id: string },
}) => {
  if (typeof id !== "number") notFound();

  const issue = await prisma.issue.findUnique({
    where: { id: parseInt(id) },
  });

  if (!issue) notFound(); // don't use return notFound(); It return null

  return (
    <div>
      <p>{issue.title}</p>
      <p>{issue.description}</p>
      <p>{issue.status}</p>
      <p>{issue.createdAt.toDateString()}</p>
    </div>
  );
};

// issues/page.tsx
<Link href={`/issues/${issue.id}`}>{issue.title}</Link>;
```

### - Styling the Issue Detail Page

```jsx
// issues/[id]/page.tsx
import IssueStatusBadge from "@/app/components/IssueStatusBadge";
import prisma from "@/prisma/client";

const SingleIssuePage = async ({
  params: { id },
}: {
  params: { id: string },
}) => {
  const issue = await prisma.issue.findUnique({
    where: { id: parseInt(id) },
  });

  if (!issue) notFound(); // don't use return notFound(); It return null

  return (
    <div>
      <Heading>{issue.title}</Heading>
      <Flex className="space-x-3" my="2">
        <IssueStatusBadge status={issue.status} />
        <Text>{issue.createdAt.toDateString()}</Text>
      </Flex>
      <Card>
        <p>{issue.description}</p>
      </Card>
    </div>
  );
};
```

### - Adding Markdown Preview

All description show as a paragraph but If we install packege react-markdown then it shows like heading, list, bold etc

```bash
npm i react-markdown
```

Now everything comes properly [See](https://prnt.sc/twmcz8O_L0yh). Only problem is tailwind by default desable some style. So we need to install a packeg which will give beautiful style.

```

```

Step 1: Install

```bash
npm install -D @tailwindcss/typography
```

Step 2: Add to plugins
require('@tailwindcss/typography') put this in plagins array of tailwind.config.ts

```jsx
// tailwind.config.ts
plugins: [require("@tailwindcss/typography")],
```

Step 3: add prose

```jsx
<Card className="prose">
  <ReactMarkdown>{issue.description}</ReactMarkdown>
</Card>
```

```jsx
// issues/[id]/page.tsx
return (
  <div>
    <Heading>{issue.title}</Heading>
    <Flex className="space-x-3" my="2">
      <IssueStatusBadge status={issue.status} />
      <Text>{issue.createdAt.toDateString()}</Text>
    </Flex>
    <Card className="prose" mt="4">
      <ReactMarkdown>{issue.description}</ReactMarkdown>
    </Card>
  </div>
);
```

### - Buliding a Styled Link Component (components/Link.tsx)

- Custom link creation. Combine next link which has client side navigation. Radix link has beautiful look and feel. Hear combine both

```jsx
import NextLink from "next/link";
import { Link as RadixLink } from "@radix-ui/themes";

interface Props {
  href: string;
  children: string;
}

const Link = ({ href, children }: Props) => {
  // next link pass two props
  return (
    <NextLink href={href} passHref legacyBehavior>
      <RadixLink>{children}</RadixLink>
    </NextLink>
  );
};
```

### - Additional Loading Skeletons (Single issue loading page)

- Copy orginal markup of single issue then place loading Skeleton.
- Use await delay(3000) to watch it poperly.

```jsx
// issues/[id]/loading.tsx
import Skeleton from "react-loading-skeleton";
import "react-loading-skeleton/dist/skeleton.css";

const LoadingIssueDetailsPage = () => {
  return (
    <Box className="max-w-xl">
      <Skeleton />
      <Flex className="space-x-3" my="2">
        <Skeleton width="3rem" />
        <Skeleton width="5rem" />
      </Flex>
      <Card className="prose" mt="4">
        <Skeleton count={5} />
      </Card>
    </Box>
  );
};

// issues/new/loading.tsx
import { Box } from "@radix-ui/themes";
import Skeleton from "react-loading-skeleton";
import "react-loading-skeleton/dist/skeleton.css";

const LoadingNewIssuePage = () => {
  return (
    <Box className="max-w-xl">
      <Skeleton />
      <Skeleton height="20rem" />
    </Box>
  );
};
```

### - Disabling Server-side Rendering

```jsx
import dynamic from "next/dynamic";

const SimpleMDE = dynamic(() => import("react-simplemde-editor"), {
  ssr: false,
});
```

### - Refactoring: Organizing Imports

- Run "Organized Import"
- In components folder many component. We can combine in components/index.js

```jsx
// components/index.js
import Link from "./Link";
import ErrorMessage from "./ErrorMessage";
import IssueStatusBadge from "./IssueStatusBadge";
import Spinner from "./Spinner";

export { Link };
export { ErrorMessage };
export { IssueStatusBadge };
export { Spinner };

// Or One Line export-import
export { default as Link } from "./Link";
export { default as ErrorMessage } from "./ErrorMessage";
export { default as Skeleton } from "./Skeleton";

// components/Skeleton.ts
import Skeleton from "react-loading-skeleton";
import "react-loading-skeleton/dist/skeleton.css";

export default Skeleton;

// components/index.js
export { default as Skeleton } from "./Skeleton";

// issues/page.tsx
import { IssueStatusBadge, Link } from "@/app/components"; // index.js so not need to add it
// loading.tsx
import { Skeleton } from "@/app/components";
```

## Ch-4: Updating Issues

### - Add the edit Button (Just creating UI no functionality)

- Radix ui Grid component with dynamic colums by passing object
- Install radix-ui icons for pencil icon

```bash
npm i @radix-ui/react-icons
```

```jsx
// issues/page.tsx
return (
  <Grid columns={{ initial: "1", md: "2" }}>
    <Box>
      <Heading>{issue.title}</Heading>
      <Flex className="space-x-3" my="2">
        <IssueStatusBadge status={issue.status} />
        <Text>{issue.createdAt.toDateString()}</Text>
      </Flex>
      <Card className="prose" mt="4">
        <ReactMarkdown>{issue.description}</ReactMarkdown>
      </Card>
    </Box>
    <Box>
      <Button>
        <Pencil2Icon />
        <Link href={`/issues/${issue.id}/edit`}> Edit Issue</Link>
      </Button>
    </Box>
  </Grid>
);
```

### - Refactor: Applying the single responsibility Principle

- Software entity sholud have single responsibility, then the code will more maintainable, Reuseable, Extendable.
- If you have a page with a lot of import statement that is a signal violating single responsibility principle.
- We break down issues/[id]/page.tsx into EditIssueButton.tsx and IssueDetails.tsx keep same folder because it will not reuse any other pages and this is the pieces of this page.
- If only one props then inline props is good.
- By doing this break down of page.tsx, in future if we want to change th layout of the only file we have to touch page.tsx, similarly if we want to change the layout of issiue details IssueDetails.tsx is the only file we need to modify. This is the benefit of applying single responsibility principle.

```jsx
// issues/[id]/page.tsx (Just break it down)
return (
  <Grid columns={{ initial: "1", md: "2" }}>
    <Box>
      <IssueDetails issue={issue} />
    </Box>
    <Box>
      <EditIssueButton issueId={issue.id} />
    </Box>
  </Grid>
);

// IssueDetails.tsx
import { IssueStatusBadge } from "@/app/components";
import { Issue } from "@prisma/client";
import { Heading, Flex, Card, Text } from "@radix-ui/themes";
import React from "react";
import ReactMarkdown from "react-markdown";

const IssueDetails = ({ issue }: { issue: Issue }) => {
  return (
    <>
      <Heading>{issue.title}</Heading>
      <Flex className="space-x-3" my="2">
        <IssueStatusBadge status={issue.status} />
        <Text>{issue.createdAt.toDateString()}</Text>
      </Flex>
      <Card className="prose" mt="4">
        <ReactMarkdown>{issue.description}</ReactMarkdown>
      </Card>
    </>
  );
};

// EditIssueButton.tsx
import { Pencil2Icon } from "@radix-ui/react-icons";
import { Button } from "@radix-ui/themes";
import Link from "next/link";
import React from "react";

const EditIssueButton = ({ issueId }: { issueId: number }) => {
  return (
    <Button>
      <Pencil2Icon />
      <Link href={`/issues/${issueId}/edit`}> Edit Issue</Link>
    </Button>
  );
};
```

### - Building the edit issue page (Very smart work: Just copy new issue form)

1. Create folder "edit" in [id] and another folder _components in Issues folder, here use "_" to keep it out from routing system ie. you can not access here.
2. Cut everything from issues/new/page.tsx and paste it directly in \_components/IssueForm.tsx (change the component name and interface type name) and import this component in new/page.tsx and test application.
3. Create another file in edit/page.tsx and import IssueForm with issue props and in \_components/IssueForm.tsx populate input field with defaultValue props.

```jsx
// new/page.tsx
import IssueForm from "../_components/IssueForm";

const NewIssuePage = () => {
  return <IssueForm />;
};

export default NewIssuePage;

// [id]/edit/page.tsx
import IssueForm from "../../_components/IssueForm";
import prisma from "@/prisma/client";
import { notFound } from "next/navigation";

interface Props {
  params: { id: string };
}

const EditIssuePage = async ({ params }: Props) => {
  const issue = await prisma.issue.findUnique({
    where: { id: parseInt(params.id) },
  });

  if (!issue) notFound();

  return <IssueForm issue={issue} />;
};

// issues/_components/IssueForm.tsx (First copy exactly from new/page.tsx then some rename and receive some props and put that as value of input fields)
(" use client ");
import ErrorMessage from "@/app/components/ErrorMessage";
import Spinner from "@/app/components/Spinner";
import { createIssueSchema } from "@/app/validationSchema";
import { zodResolver } from "@hookform/resolvers/zod";
import { Issue } from "@prisma/client";
import { Button, Callout, TextField } from "@radix-ui/themes";
import axios from "axios";
import "easymde/dist/easymde.min.css";
import dynamic from "next/dynamic";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { Controller, useForm } from "react-hook-form";
import { z } from "zod";

const SimpleMDE = dynamic(() => import("react-simplemde-editor"), {
  ssr: false,
});

type IssueFormData = z.infer<typeof createIssueSchema>;

const IssueForm = ({ issue }: { issue?: Issue }) => {
  const router = useRouter();
  const {
    register,
    control,
    handleSubmit,
    formState: { errors },
  } = useForm <
  IssueFormData >
  {
    resolver: zodResolver(createIssueSchema),
  };
  // console.log(errors);
  const [error, setError] = useState(""); // to handel error comes form server
  const [isSubmitting, setSubmitting] = useState(false);

  const onSubmit = handleSubmit(async (data) => {
    try {
      setSubmitting(true);
      await axios.post("/api/issues", data);
      router.push("/issues");
    } catch (error) {
      // console.log(error);
      setSubmitting(false);
      setError("An unexpected error occurred.");
    }
  });

  return (
    <div className="max-w-xl">
      {error && (
        <Callout.Root color="red" className="mb-3">
          <Callout.Text>{error}</Callout.Text>
        </Callout.Root>
      )}
      <form className="space-y-3" onSubmit={onSubmit}>
        <TextField.Root
          defaultValue={issue?.title}
          placeholder="Title"
          {...register("title")}
        />
        <ErrorMessage>{errors.title?.message}</ErrorMessage>
        <Controller
          name="description"
          control={control}
          defaultValue={issue?.description}
          render={({ field }) => (
            <SimpleMDE placeholder="Description" {...field} />
          )}
        />
        <ErrorMessage>{errors.description?.message}</ErrorMessage>
        <Button type="submit">
          Submit New Issue {isSubmitting && <Spinner />}
        </Button>
      </form>
    </div>
  );
};
```

### - Building an API for updating Issue (api/issues/[id]/route.ts)

**PUT: Replacing entire Object** <br>
**PATCH: Updating one or more property**

- Careful: add "await" before request.json() and return before NextResponse.json()

1. Check request body
2. Check issue in DB
3. Update and Return

```jsx
// api/issues/[id]/route.ts
import { IssueSchema } from "@/app/validationSchema";
import prisma from "@/prisma/client";
import { NextRequest, NextResponse } from "next/server";

export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const body = await request.json();
  const validation = IssueSchema.safeParse(body);

  if (!validation.success)
    return NextResponse.json(validation.error.format(), { status: 400 });

  const issue = await prisma.issue.findUnique({
    where: { id: parseInt(params.id) },
  });

  if (!issue)
    return NextResponse.json({ error: "Invald Issue" }, { status: 404 });

  const updatedIssue = await prisma.issue.update({
    where: { id: issue?.id },
    data: {
      title: body.title,
      description: body.description,
    },
  });

  return NextResponse.json(updatedIssue);
}
```

### - Updating Issues (\_components/IssueForm.tsx)

**Two Places need to update**

1. if (issue) await axios.patch(`/api/issues/${issue.id}`, data);
   else await axios.post("/api/issues", data);
2. {issue ? "Update Issue" : "Submit New Issue"}

```jsx
"use client";
import { Controller, useForm } from "react-hook-form";
import { z } from "zod";

const SimpleMDE = dynamic(() => import("react-simplemde-editor"), {
  ssr: false,
});

type IssueFormData = z.infer<typeof IssueSchema>;

const IssueForm = ({ issue }: { issue?: Issue }) => {
  const router = useRouter();
  const {
    register,
    control,
    handleSubmit,
    formState: { errors },
  } = useForm <
  IssueFormData >
  {
    resolver: zodResolver(IssueSchema),
  };
  // console.log(errors);
  const [error, setError] = useState(""); // to handel error comes form server
  const [isSubmitting, setSubmitting] = useState(false);

  const onSubmit = handleSubmit(async (data) => {
    try {
      setSubmitting(true);
      if (issue) await axios.patch(`/api/issues/${issue.id}`, data);
      else await axios.post("/api/issues", data);
      router.push("/issues");
    } catch (error) {
      // console.log(error);
      setSubmitting(false);
      setError("An unexpected error occurred.");
    }
  });

  return (
    <div className="max-w-xl">
      {error && (
        <Callout.Root color="red" className="mb-3">
          <Callout.Text>{error}</Callout.Text>
        </Callout.Root>
      )}
      <form className="space-y-3" onSubmit={onSubmit}>
        <TextField.Root
          defaultValue={issue?.title}
          placeholder="Title"
          {...register("title")}
        />
        <ErrorMessage>{errors.title?.message}</ErrorMessage>
        <Controller
          name="description"
          control={control}
          defaultValue={issue?.description}
          render={({ field }) => (
            <SimpleMDE placeholder="Description" {...field} />
          )}
        />
        <ErrorMessage>{errors.description?.message}</ErrorMessage>
        <Button type="submit">
          {issue ? "Update Issue" : "Submit New Issue"}{" "}
          {isSubmitting && <Spinner />}
        </Button>
      </form>
    </div>
  );
};
```

### - Understanding Caching (3 types- Data(Server), Full Route(Server), Router(Client)) VVI

1. Data Cache: When we fetch data using fetch(): Stored in file system, Permanent untill re-deploy (Cache on the server)

```jsx
fetch("...", { cache: "no-store" });
fetch("...", { next: { revalidate: 3600 } }); // 3600sec
```

2. Full Route Cache (Cache on the server): Used to store the output of statically rendered routes. (o static rendiring - build time) (λ dynamic routing - request time)<br >
   NextJS Don't have a parameter static route by default. [Click](https://prnt.sc/RS4uaYXk2Eeo)<br>
   Build application(npm run build) and Start builded app(npm start)<br>
   o Static rendiring: Data will not refetching no metter what how many refresh you are doing. Need to re-build<br>
   Export force-dynamic to make static page dynamic. [Result](https://prnt.sc/CyTC6RT4Ocz6)

```jsx
// issues/page.tsx
      </Table.Root>
    </div>
  );
};

export const dynamic = "force-dynamic"; // TO make a static page dynamic
// export const revalidate = 10; // revalidate every 10 sec

export default IssuesPage;
```

3. Router Cache (Client Cache): To store the payload of pages in browser, refreshed when we reload. If one page is fetched then need not to make network request.<br>
   For, o Static route client cache invalidation period is 5 min (After this period refetch from network)<br>
   For, λ Dynamic route client cache invalidation period is 30 sec

```jsx
// IssueForm.tsx (Tell next js refresh the content of the current route)
router.push("/issues");
router.refresh();
```

### - Improving the Loading Experience. Lazy Loading

- Load add or update IssueForm lazy and at a time.
- Use dynamic() for lazy loading

```jsx
// new/page.tsx
import dynamic from "next/dynamic";
import IssueFormSkeleton from "../_components/IssueFormSkeleton";

const IssueForm = dynamic(() => import("@/app/issues/_components/IssueForm"), {
  ssr: false,
  loading: () => <IssueFormSkeleton />,
});

const NewIssuePage = () => {
  return <IssueForm />;
};

// IssueForm.tsx (Import directly because it will load using dynamic funciton and ssr: false)
const SimpleMDE = dynamic(() => import("react-simplemde-editor"), { // old
  ssr: false,
});
to--->
import SimpleMdeReact from "react-simplemde-editor"; // New
```

- Create \_components/IssueFormSkeleton.tsx, it repeate several places

```jsx
// _components/IssueFormSkeleton.tsx
import { Box } from "@radix-ui/themes";
import { Skeleton } from "@/app/components";

const IssueFormSkeleton = () => {
  return (
    <Box className="max-w-xl">
      <Skeleton height="2rem" />
      <Skeleton height="20rem" />
    </Box>
  );
};

// in loading.tsx
import IssueFormSkeleton from "../../_components/IssueFormSkeleton";
export default IssueFormSkeleton;
```

## Ch-5: Deleting Issues

### - Adding a delete button (DeleteIssueButton.tsx)

- Here some important critical markup is present. Need to understand.

```jsx
// issues/[id]/page.tsx | md in taiwind is equvalent to sm in redix
return (
  <Grid columns={{ initial: "1", sm: "5" }} gap="3">
    <Box className="md:col-span-4">
      <IssueDetails issue={issue} />
    </Box>
    <Box>
      <Flex direction="column" gap="4">
        <EditIssueButton issueId={issue.id} />
        <DeleteIssueButton issueId={issue.id} />
      </Flex>
    </Box>
  </Grid>
);

// issues/[id]/DeleteIssueButton.tsx
import { Button } from "@radix-ui/themes";
import React from "react";

const DeleteIssueButton = ({ issueId }: { issueId: number }) => {
  return <Button color="red">Delete Issue</Button>;
};

// app/layout.tsx (Add container so that no matter what screen, it provide a fixed size and certer the page)
<main className="p-5 radix-themes">
  <Container>{children}</Container>
</main>;
```

### - Adding a Confirmation Dialog Box

```jsx
// issues/[id]/DeleteissueButton.tsx
return (
  <AlertDialog.Root>
    <AlertDialog.Trigger>
      <Button color="red">Delete Issue</Button>
    </AlertDialog.Trigger>
    <AlertDialog.Content>
      <AlertDialog.Title>Delete Confirmation</AlertDialog.Title>
      <AlertDialog.Description>
        Are you sure you want to delete this issue? This action can not be
        undone.
      </AlertDialog.Description>
      <Flex gap="3" mt="4">
        <AlertDialog.Cancel>
          <Button variant="soft" color="gray">
            Cancel
          </Button>
        </AlertDialog.Cancel>
        <AlertDialog.Action>
          <Button variant="solid" color="red">
            Delete Issue
          </Button>
        </AlertDialog.Action>
      </Flex>
    </AlertDialog.Content>
  </AlertDialog.Root>
);
```

### - Building an API & Delete an issue

- First build api then add api link to markup using axios

```jsx
// api/issues/[id]/route.ts (Just copy from PUTCH)
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const issue = await prisma.issue.findUnique({
    where: { id: parseInt(params.id) },
  });

  if (!issue)
    return NextResponse.json({ error: "Invald Issue" }, { status: 404 });

  await prisma.issue.delete({
    where: { id: issue?.id },
  });

  return NextResponse.json({});
}

// issues/[id]/DeleteIssueButton.tsx (useRouter form navigatioin)
("use client");
import { Button, AlertDialog, Flex, Link } from "@radix-ui/themes";
import axios from "axios";
import { useRouter } from "next/navigation";

const DeleteIssueButton = ({ issueId }: { issueId: number }) => {
  const router = useRouter();

  return (
    <AlertDialog.Root>
      <AlertDialog.Trigger>
        <Button color="red">Delete Issue</Button>
      </AlertDialog.Trigger>
      <AlertDialog.Content>
        <AlertDialog.Title>Delete Confirmation</AlertDialog.Title>
        <AlertDialog.Description>
          Are you sure you want to delete this issue? This action can not be
          undone.
        </AlertDialog.Description>
        <Flex gap="3" mt="4">
          <AlertDialog.Cancel>
            <Button variant="soft" color="gray">
              Cancel
            </Button>
          </AlertDialog.Cancel>
          <AlertDialog.Action>
            <Button
              color="red"
              onClick={async () => {
                await axios.delete("/api/issues/" + issueId);
                router.push("/issues");
                router.refresh(); // Cache refresh
              }}
            >
              Delete Issue
            </Button>
          </AlertDialog.Action>
        </Flex>
      </AlertDialog.Content>
    </AlertDialog.Root>
  );
};
```

### - Handling Errors

- If there is less code then one line when increase code line then separate code. No need to do over engineering for one liner.

```jsx
// issues/[id]/DeleteIssueButon.tsx (If less code then one line)
<Button
  color='red'
  onClick={async () => {
    await axios.delete("/api/issues/" + issueId);
    router.push("/issues");
    router.refresh();
  }}
>
  Delete Issue
</Button>

// This code could be with error handeliing
const deleteIssue = async () => {
  try {
    // throw new Error();
    await axios.delete("/api/issues/" + issueId);
    router.push("/issues");
    router.refresh();
  } catch (error) {
    setError(true);
  }
};

return(
  <Button color='red' onClick={deleteIssue}>
    Delete Issue
  </Button>;
)
```

### - Improving the User Experience (Showing Spinner while deleting)

```jsx
// issues/[id]/DeleteIssueButton.tsx (<Spinner> theat we create in component)
<Button color='red' disabled={isDeleting}>
  Delete Issue {isDeleting && <Spinner />}
</Button>

// api/issues/[id]/route.ts
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  delay(3000); // To simulate delay
  ............
}

```

### - Removing Duplicate Skeletons (Commonn loading is not get loded for skeleton. )

Restructure file-folder to get ride of load common loading.tsx <br>
issues/allFiles -> issues/list <br>
issues/[id]/edit -> issues/edit/[id] <br>
Search and Replace link [Click](https://prnt.sc/88p8fq6gUiSr)

```jsx
// EditIssueButton.tsx (Update link also)
<Link href={`/issues/edit/${issueId}`}> Edit Issue</Link>;

// NavBar.tsx
const links = [
  { label: "Dashboard", href: "/" },
  { label: "Issues", href: "/issues/list" },
];

// DeleteIssueButton.tsx (router.push("/issues/list"))
const deleteIssue = async () => {
  try {
    // throw new Error();
    setDeleting(true);
    await axios.delete("/api/issues/" + issueId);
    router.push("/issues/list");
    router.refresh();
  } catch (error) {
    setDeleting(false);
    setError(true);
  }
};
```

## Ch-6: Authentication

### - Setting Up NextAuth

```bash
npm install next-auth
```

In NextAuth we need to pass configaration objects like providers, adapters

```jsx
// /app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth";

const handler = NextAuth({
  providers: [],
});

export { handler as GET, handler as POST };
```

To encrypt sign authentication key using a random character. To generate ramdom string run this in terminal or [openssl](https://www.cryptool.org/en/cto/openssl/)

```bash
openssl rand -base64 32 // https://prnt.sc/HBzZGF62p2Y8
```

### - Configuring Google Provider (Add .env to .gitignore)

1. Consent Screen setup (External, App name & Support & Developer Email, Scopes-Email+Profile, No Test User, Publish)
2. Credentials -> Create Credentials -> OAuth client ID. [See](https://prnt.sc/ZZ4F4uzYRaUt)

- Authorized JavaScript origins - http://localhost:3000 or Production site name
- Authorized redirect URIs - http://localhost:3000/api/auth/callback/google

- Add link to NavBar { label: "Login", href: "/api/auth/signin" } <br>
  To see the login user. JSON Web Token

```jsx
// /app/auth/token/route.ts (OutPut: https://prnt.sc/-wnwXozYhnhP)
import { getToken } from "next-auth/jwt";
import { NextRequest, NextResponse } from "next/server";

export async function GET(request: NextRequest) {
  const token = await getToken({ req: request });

  return NextResponse.json(token);
}
```

```jsx
// .env file
// DATABASE_URL = "mysql://root:@localhost:3306/issue-tracker"
// NEXTAUTH_URL = "http://localhost:3000"
// NEXTAUTH_SECRET = wdyN1qkDG5W0lESPiEMkj6UweqVm1vgnIvSQ8tEOjsE=
// GOOGLE_CLIENT_ID = 8etmfb88qp1runte5v6la30.apps.googleusercontent.com
// GOOGLE_CLIENT_SECRET = drrXvcMlrKsm2XmX
```

### - Adding Prisma Adapter (Google User store Local site in DB)

Go to [https://authjs.dev/getting-started/adapters/prisma](https://authjs.dev/getting-started/adapters/prisma)

- Run this commands

```bash
npm install @next-auth/prisma-adapter
```

```bash
npx prisma format
npx prisma migrate dev
```

- Use this if you get prisma migration error

```jsx
// @db.VarChar(100), default: @db.VarChar(191)
model Account {
provider          String  @db.VarChar(100)
providerAccountId String  @db.VarChar(100)

model VerificationToken {
identifier String   @db.VarChar(100)
token      String   @unique @db.VarChar(100)
```

```jsx
// /app/api/auth/[...nextauth]/route.ts (Neet to change strategy to jwt)
import GoogleProvider from "next-auth/providers/google";
import NextAuth from "next-auth";
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import prisma from "@/prisma/client";

const handler = NextAuth({
  adapter: PrismaAdapter(prisma),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
  ],
  session: {
    strategy: "jwt",
  },
});

export { handler as GET, handler as POST };

```

### - Add the login and logout links (NabBar.tsx with some fixes for useSession)

- If we use useSession then we need to do 2 thing, 1: Create AuthProvider, 2: Wrap Layout with AuthProvider

```jsx
"use client";

import { useSession } from "next-auth/react";

const NavBar = () => {
  const currentPath = usePathname();
  const { status, data: session } = useSession();
  // console.log(currentPath);
  const links = [
    { label: "Dashboard", href: "/" },
    { label: "Issues", href: "/issues/list" },
  ];

  return (
      <ul className='flex space-x-6'>
        {links.map((link) => (
          <li key={link.href}>
            <Link
              className={classNames({
                "text-zinc-900": link.href === currentPath,
                "text-zinc-500": link.href !== currentPath,
                "hover:text-zinc-800 transition-colors": true,
              })}
              href={link.href}
            >
              {link.label}
            </Link>
          </li>
        ))}
      </ul>
      <Box>
        {status === "unauthenticated" ? (
          <Link href='/api/auth/signin'>Login</Link>
        ) : (
          <Link href='/api/auth/signout'>Logout</Link>
        )}
      </Box>
    </nav>
  );
};

// app/auth/Provider.tsx
"use client";

import { SessionProvider } from "next-auth/react";
import React, { PropsWithChildren } from "react";

const AuthProvider = ({ children }: PropsWithChildren) => {
  return <SessionProvider>{children}</SessionProvider>;
};

export default AuthProvider;


// app/layout.tsx (wrap what inside body with <AuthProvider>)
import AuthProvider from "./auth/Provider";

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang='en'>
      <body className={inter.variable}>
        <AuthProvider> // Added
          <Theme accentColor='violet'>
            <NavBar />
            <main className='p-5 radix-themes'>
              <Container>{children}</Container>
            </main>
          </Theme>
        </AuthProvider>
      </body>
    </html>
  );
}

```

### - Changing Layout of the NavBar (NavBar.tsx) Many thing there need to learn about CSS

```jsx
// NavBar.tsx
"use client";

const NavBar = () => {
  const currentPath = usePathname();
  const { status, data: session } = useSession();
  // console.log(currentPath);
  const links = [
    { label: "Dashboard", href: "/" },
    { label: "Issues", href: "/issues/list" },
  ];
  return (
    <nav className="space-x-6 border-b mb-5 py-3">
      <Container>
        <Flex justify="between">
          <Flex align="center" gap="3">
            <Link href="/">
              <AiFillBug />
            </Link>
            <ul className="flex space-x-6">
              {links.map((link) => (
                <li key={link.href}>
                  <Link
                    className={classNames({
                      "text-zinc-900": link.href === currentPath,
                      "text-zinc-500": link.href !== currentPath,
                      "hover:text-zinc-800 transition-colors": true,
                    })}
                    href={link.href}
                  >
                    {link.label}
                  </Link>
                </li>
              ))}
            </ul>
          </Flex>
          <Box>
            {status === "unauthenticated" ? (
              <Link href="/api/auth/signin">Login</Link>
            ) : (
              <Link href="/api/auth/signout">Logout</Link>
            )}
          </Box>
        </Flex>
      </Container>
    </nav>
  );
};
```

### - Add a drop-down menu to show the current user (NavBar.tsx)

- Just used radix DropDownMenu

```jsx
// NavBar.tsx
const NavBar = () => {
  const currentPath = usePathname();
  const { status, data: session } = useSession();

  const links = [
    { label: "Dashboard", href: "/" },
    { label: "Issues", href: "/issues/list" },
  ];

  return (
    <nav className='border-b mb-5 px-5 py-3'>
      <Container>
        <Flex justify='between'>
          <Flex align='center' gap='3'>
            <Link href='/'>
              <AiFillBug />
            </Link>
            <ul className='flex space-x-6'>
              {links.map((link) => (
                <li key={link.href}>
                  <Link
                    className={classnames({
                      "text-zinc-900": link.href === currentPath,
                      "text-zinc-500": link.href !== currentPath,
                      "hover:text-zinc-800 transition-colors": true,
                    })}
                    href={link.href}
                  >
                    {link.label}
                  </Link>
                </li>
              ))}
            </ul>
          </Flex>
          <Box>
            {status === "unauthenticated" ? (
              <Link href='/api/auth/signin'>Login</Link>
            ) : (
              <DropdownMenu.Root>
                <DropdownMenu.Trigger>
                  <Avatar
                    src={session?.user!.image!}
                    fallback='?'
                    size='3'
                    radius='full'
                    className='cursor-pointer'
                  />
                </DropdownMenu.Trigger>
                <DropdownMenu.Content>
                  <DropdownMenu.Label>
                    <Text size='2'>{session?.user?.email}</Text>
                  </DropdownMenu.Label>
                  <DropdownMenu.Item>
                    <Link href='/api/auth/signout'>Logout</Link>
                  </DropdownMenu.Item>
                </DropdownMenu.Content>
              </DropdownMenu.Root>
            )}
          </Box>
        </Flex>
      </Container>
    </nav>
  );
};
```

### - Troubleshooting: Avatar Not Loading

- Normally avater load autometically. If not then follow step1 if not work then together with step2

```jsx
// Step1: NavBar.tsx
<Avatar
  src={session?.user!.image!}
  fallback='?'
  size='3'
  radius='full'
  className='cursor-pointer'
  referrerPolicy='no-referrer'
/>

// Step2: next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  async headers() {
    return [
      {
        source: "/:path*",
        headers: [{ key: "referrer-policy", value: "no-referrer" }],
      },
    ];
  },
};

export default nextConfig;

```

### - Refactoring the NavBar (NavBar.tsx) Create component inside single file

**Create two components AuthStatus & NavLinks inside same file. You can do it in another file. Illustrating just another way. There is no right or wrong here.**<br>
**By doing so, NavBar has now single responsibility of laying out NavBar only**<br>
**In AuthStatus very professional way of return in 3 conditions**<br>
**In globals.css create single .nav-link class combining 3 tailwind class**<br>
**! in tailwind is !important modifire in css**<br>

```jsx
// NavBar.tsx
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import React from "react";
import { AiFillBug } from "react-icons/ai";
import classnames from "classnames";
import { useSession } from "next-auth/react";
import {
  Avatar,
  Box,
  Container,
  DropdownMenu,
  Flex,
  Text,
} from "@radix-ui/themes";

const NavBar = () => {
  return (
    <nav className='border-b mb-5 px-5 py-3'>
      <Container>
        <Flex justify='between'>
          <Flex align='center' gap='3'>
            <Link href='/'>
              <AiFillBug />
            </Link>
            <NavLinks />
          </Flex>
          <AuthStatus />
        </Flex>
      </Container>
    </nav>
  );
};

const NavLinks = () => {
  const currentPath = usePathname();

  const links = [
    { label: "Dashboard", href: "/" },
    { label: "Issues", href: "/issues/list" },
  ];

  return (
    <ul className='flex space-x-6'>
      {links.map((link) => (
        <li key={link.href}>
          <Link
            className={classnames({
              "nav-link": true,
              "!text-zinc-900": link.href === currentPath,
            })}
            href={link.href}
          >
            {link.label}
          </Link>
        </li>
      ))}
    </ul>
  );
};

const AuthStatus = () => {
  const { status, data: session } = useSession();

  if (status === "loading") return null;

  if (status === "unauthenticated")
    return (
      <Link className='nav-link' href='/api/auth/signin'>
        Login
      </Link>
    );

  return (
    <Box>
      <DropdownMenu.Root>
        <DropdownMenu.Trigger>
          <Avatar
            src={session?.user!.image!}
            fallback='?'
            size='3'
            radius='full'
            className='cursor-pointer'
            referrerPolicy='no-referrer'
          />
        </DropdownMenu.Trigger>
        <DropdownMenu.Content>
          <DropdownMenu.Label>
            <Text size='2'>{session?.user?.email}</Text>
          </DropdownMenu.Label>
          <DropdownMenu.Item>
            <Link href='/api/auth/signout'>Logout</Link>
          </DropdownMenu.Item>
        </DropdownMenu.Content>
      </DropdownMenu.Root>
    </Box>
  );
};
export default NavBar;

```

```css
/* globals.css */
@layer utilities {
  .nav-link {
    @apply text-zinc-500 hover:text-zinc-800 transition-colors;
  }
}
```

### - Adding a Login Loading Skeleton

```jsx
// NavBar.tsx (This Skeleton contains both js and css in one place)
import { Skeleton } from "@/app/components";

if (status === "loading") return <Skeleton width="3rem" />;
```

### - Securing the Application (Couple of thing included to provide security for both fontend and backend )

- In middleware.ts we just need to add all url in matcher array. Next-Auth redirect if to login page if not login.

```jsx
// middleware.ts (in root directory not in App directory)
export { default } from "next-auth/middleware";

export const config = {
  matcher: ["/issues/new", "/issues/edit/:id+"],
};
```

- To getServerSession(), create app/auth/authOptions.ts just configaratin object which is just cut from api/auth/[...nextauth]/router.ts

```jsx
// app/auth/authOptions.ts
import GoogleProvider from "next-auth/providers/google";
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import prisma from "@/prisma/client";
import { NextAuthOptions } from "next-auth";

const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
  ],
  session: {
    strategy: "jwt",
  },
};

export default authOptions;

// api/auth/[...nextauth]/router.ts
import authOptions from "@/app/auth/authOptions";
import NextAuth from "next-auth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

```

- Using server session on Issue Page. app/issues/[id]/page.tsx. Tricks: For conditional rendering some elements first wrap inside <>Ok</> -> {<>Ok</>} -> {session && <>Ok</>}

```jsx
// app/issues/[id]/page.tsx
const session = await getServerSession(authOptions);

{
  session && (
    <Box>
      <Flex direction="column" gap="4">
        <EditIssueButton issueId={issue.id} />
        <DeleteIssueButton issueId={issue.id} />
      </Flex>
    </Box>
  );
}
```

- Securing API | Here also getServerSession(authOptions). [Postman Output](https://prnt.sc/_kc8ct7wQIL7)

```jsx
// api/issues/route.ts [@POST]
export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({}, { status: 401 });

  const body = await request.json();

  const validation = IssueSchema.safeParse(body);

  if (!validation.success)
    return NextResponse.json(validation.error.format(), { status: 400 });

  const newIssue = await prisma.issue.create({
    data: {
      title: body.title,
      description: body.description,
    },
  });

  return NextResponse.json(newIssue, { status: 201 });
}
```

## Ch-7: Assigning Issues to Users

### - Building the Assignee Select Component (AssigneeSelect.tsx) Just use radix < Select >

```jsx
// issues/[id]/AssigneeSelect.tsx
import { Select } from "@radix-ui/themes";

const AssigneeSelect = () => {
  return (
    <Select.Root>
      <Select.Trigger placeholder="Assign..." />
      <Select.Content>
        <Select.Group>
          <Select.Label>Suggestion</Select.Label>
          <Select.Item value="1">Subroto Biswas</Select.Item>
        </Select.Group>
      </Select.Content>
    </Select.Root>
  );
};

// issues/[id]/page.tsx (just use upper component)
<Box>
  <Flex direction="column" gap="4">
    <AssigneeSelect />
    <EditIssueButton issueId={issue.id} />
    <DeleteIssueButton issueId={issue.id} />
  </Flex>
</Box>;
```

### - Populating the Assignee Select Component

- Building API and access data from AssigneeSelect.tsx

```jsx
// api/users/route.ts (Building API)
import prisma from "@/prisma/client";
import { NextRequest, NextResponse } from "next/server";

export async function GET(request: NextRequest) {
  const user = await prisma.user.findMany();
  return NextResponse.json(user);
}

// issues/[id]/AssigneeSelect.tsx
import { User } from "@prisma/client";
import { Select } from "@radix-ui/themes";

const AssigneeSelect = async () => {
  const res = await fetch("http://localhost:3000/api/users");
  const users: User[] = await res.json();

  return (
    <Select.Root>
      <Select.Trigger placeholder="Assign..." />
      <Select.Content>
        <Select.Group>
          <Select.Label>Suggestion</Select.Label>
          {users.map((user) => (
            <Select.Item value={user.id}>{user.name}</Select.Item>
          ))}
        </Select.Group>
      </Select.Content>
    </Select.Root>
  );
};
```

NB: If you want to access API from client component (use client) need to use axios and keep data in state variable

### - Add Assigned Issues to Prisma Schema (schema.prisma)

- Making relathonship

```jsx
// prisma/schema.prisma
model Issue {
  ......
  assignedToUserId String?  @db.VarChar(100) // foriegn key
  assignedToUser   User?    @relation(fields: [assignedToUserId], references: [id]) // For make it happen in prisma
}

model User {
  .......
  assignedIssues Issue[] // for make it happen in prisma
}
```

### - Enhance the API to assign issues (validationSchema.ts, api/issues/[id]/route.ts)

- Added new zod schema(patchIssueSchema) which allow request body {title, description, assignedToUserId} optional. Because sometimes title and description are given but not assignedToUserId and vice versa

```jsx
// validationSchema.ts (add new schema patchIssueSchema for PATCH function )
import { z } from "zod";

export const IssueSchema = z.object({
  title: z.string().min(1, "Title is required.").max(255),
  description: z.string().min(1, "Description is required.").max(65535),
});

export const patchIssueSchema = z.object({
  title: z.string().min(1, "Title is required.").max(255).optional(),
  description: z
    .string()
    .min(1, "Description is required.")
    .max(65535)
    .optional(),
  assignedToUserId: z
    .string()
    .min(1, "AssignedToUserId is required.")
    .max(100)
    .optional()
    .nullable(),
});

// api/issues/[id]/route.ts (If assignedToUserId is null then it also updated as null. Will not catch in checking)
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({}, { status: 401 });

  const body = await request.json();
  const validation = patchIssueSchema.safeParse(body);

  if (!validation.success)
    return NextResponse.json(validation.error.format(), { status: 400 });

  const { assignedToUserId, title, description } = body;

  if (assignedToUserId) {
    const user = await prisma.user.findUnique({
      where: {
        id: assignedToUserId,
      },
    });
    if (!user)
      return NextResponse.json({ error: "Invalid User" }, { status: 400 });
  }

  const issue = await prisma.issue.findUnique({
    where: { id: parseInt(params.id) },
  });

  if (!issue)
    return NextResponse.json({ error: "Invald Issue" }, { status: 404 });

  const updatedIssue = await prisma.issue.update({
    where: { id: issue?.id },
    data: {
      title,
      description,
      assignedToUserId,
    },
  });

  return NextResponse.json(updatedIssue);
}
```

### - Assigning an Issue to a User (AssigneeSelect.tsx)

- Fetch API [(GET, POST, PUT, PATCH, DELETE)](https://www.freecodecamp.org/news/javascript-fetch-api-for-beginners/#how-to-send-a-patch-request)
- Connect UI to API

```jsx
// app/issues/[id]/page.tsx
<IssueDetails issue={issue} />

// app/issues/[id]/AssigneeSelect.tsx
"use client";
import { Issue, User } from "@prisma/client";
import { Select } from "@radix-ui/themes";
import axios from "axios";
import { useEffect, useState } from "react";

const AssigneeSelect = ({ issue }: { issue: Issue }) => {
  const [users, setUsers] = useState<User[]>();
  // const res = await fetch("http://localhost:3000/api/users");
  useEffect(() => {
    axios
      .get<User[]>("http://localhost:3000/api/users")
      .then((res) => {
        setUsers(res.data);
        console.log(res.data);
      })
      .catch((err) => console.log(err));
  }, []);

  return (
    <Select.Root
      defaultValue={issue.assignedToUserId || "unassigned"}
      onValueChange={(userId) => {
        const valueUserId = userId === "unassigned" ? null : userId;
        fetch("http://localhost:3000/api/issues/" + issue.id, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            assignedToUserId: valueUserId,
          }),
        });
      }}
    >
      <Select.Trigger placeholder="Assign..." />
      <Select.Content>
        <Select.Group>
          <Select.Label>Suggestion</Select.Label>
          <Select.Item value="unassigned">Unassigned</Select.Item> // here value='' can not assign so we do this
          {users?.map((user) => (
            <Select.Item key={user.id} value={user.id}>
              {user.name}
            </Select.Item>
          ))}
        </Select.Group>
      </Select.Content>
    </Select.Root>
  );
};
```

### - Showing Toast Notifications for error/success

- [react-hot-toast.com](https://react-hot-toast.com) [see](https://prnt.sc/-93jhPED48Ia)

```bash
npm install react-hot-toast
```

```jsx
// app/issues/[id]/AssigneeSelect.tsx
"use client";
import toast, { Toaster } from "react-hot-toast"; // added 1

const AssigneeSelect = ({ issue }: { issue: Issue }) => {
  return (
    <>
      <Select.Root
        defaultValue={issue.assignedToUserId || "unassigned"}
        onValueChange={(userId) => {
          const valueUserId = userId === "unassigned" ? null : userId;
          fetch("/api/issues/" + issue.id, {
            method: "PATCH",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              assignedToUserId: valueUserId,
            }),
          })
            .then((res) => {
              if (!res.ok) {
                // if you use axios then you need to to do this only .catch() work directly
                throw new Error("Network response was not ok");
              }
              toast.success("Successfully saved!");
            })
            .catch((error) => toast.error("Could not be saved.")); // added 2
        }}
      >
        <Select.Trigger placeholder="Assign..." />
        <Select.Content>
          <Select.Group>
            <Select.Label>Suggestion</Select.Label>
            <Select.Item value="unassigned">Unassigned</Select.Item>
            {users?.map((user) => (
              <Select.Item key={user.id} value={user.id}>
                {user.name}
              </Select.Item>
            ))}
          </Select.Group>
        </Select.Content>
      </Select.Root>
      <Toaster /> // Added 3
    </>
  );
};
```

### - Refactoring the Assigenee Select Component (onChange has multiple line so take it outside)

```jsx
// app/issues/[id]/AssigneeSelect.tsx
"use client";
import toast, { Toaster } from "react-hot-toast";

const AssigneeSelect = ({ issue }: { issue: Issue }) => {
  const [users, setUsers] = useState<User[]>();
  // const res = await fetch("http://localhost:3000/api/users");
  useEffect(() => {
    axios
      .get<User[]>("http://localhost:3000/api/users")
      .then((res) => {
        setUsers(res.data);
        // console.log(res.data);
      })
      .catch((err) => console.log(err.message));
  }, []);

  const assignIssue = (userId: string) => {
    const valueUserId = userId === "unassigned" ? null : userId;
    fetch("/api/issues/" + issue.id, {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        assignedToUserId: valueUserId,
      }),
    })
      .then((res) => {
        if (!res.ok) {
          // if you use axios then you need to to do this only .catch() work directly
          throw new Error("Network response was not ok");
        }
        toast.success("Successfully saved!");
      })
      .catch((error) => toast.error("Could not be saved."));
  };

  return (
    <>
      <Select.Root
        defaultValue={issue.assignedToUserId || "unassigned"}
        onValueChange={assignIssue}
      >
        <Select.Trigger placeholder="Assign..." />
        <Select.Content>
          <Select.Group>
            <Select.Label>Suggestion</Select.Label>
            <Select.Item value="unassigned">Unassigned</Select.Item>
            {users?.map((user) => (
              <Select.Item key={user.id} value={user.id}>
                {user.name}
              </Select.Item>
            ))}
          </Select.Group>
        </Select.Content>
      </Select.Root>
      <Toaster />
    </>
  );
};
```

### - Setting up React Query (QueryClientProvider.tsx, layout.tsx)

1. For conventional data fetching we use, useState + useEffect. But the porblem is no error handeling, no Call to backend fails and retry, No caching(every time call backend). Of course We can build this by hand but it is time consuming. So We will use react-query
2. QueryClient contain cache for storing data that we get from backend. We use QueryClientProvider to pass this data to component tree (as it is using react Context so it should be client component).

```bash
$ npm i react-query
```

**All about react query**

```jsx
const queryClient = new QueryClient(); // hold data cache
<QueryClientProvider client={queryClient}>{children}</QueryClientProvider>; // spread to component tree
```

**React Context is only available in client component**<br>
**Next-Crud: Project**

```jsx
// app/QueryClientProvider.tsx (This component uses react context to share queryClient with our component tree )
"use client";
import {
  QueryClient,
  QueryClientProvider as ReactQueryClientProvider, // to avoide clash with this component name
} from "@tanstack/react-query";
import { PropsWithChildren } from "react";

const queryClient = new QueryClient();

const QueryClientProvider = ({ children }: PropsWithChildren) => {
  return (
    <ReactQueryClientProvider client={queryClient}>
      {children}
    </ReactQueryClientProvider>
  );
};

// Layout.tsx
return (
  <html lang="en">
    <body className={inter.variable}>
      <QueryClientProvider>
        <AuthProvider>
          <Theme accentColor="violet">
            <NavBar />
            <main className="p-5 radix-themes">
              <Container>{children}</Container>
            </main>
          </Theme>
        </AuthProvider>
      </QueryClientProvider>
    </body>
  </html>
);
```

### - Fetching Data with React Query (AssigneeSelectReactQuery.tsx to page.tsx)

Here we properly handel error and isLoading with Skeleton. We can do caching and retring by our hand, of course it is do able but we have to solve a problem that is already solved.

```jsx
// app/issues/[id]/AssigneeSelectReactQuery.tsx
"use client";
import { Skeleton } from "@/app/components";

const AssigneeSelectReactQuery = ({ issue }: { issue: Issue }) => {
  const {
    data: users,
    error,
    isLoading,
  } = useQuery<User[]>({
    queryKey: ["users"],
    queryFn: () => axios.get("/xapi/users").then((res) => res.data),
    staleTime: 60 * 1000,
    retry: 3,
  });

  if (isLoading) return <Skeleton />; // Skeleton parent er full width ney

  if (error) return null;

  return (
    <>
      <Select.Root
        defaultValue={issue.assignedToUserId || "unassigned"}
        onValueChange={assignIssue}
      >
        <Select.Trigger placeholder="Assign..." />
        <Select.Content>
          <Select.Group>
            <Select.Label>Suggestion</Select.Label>
            <Select.Item value="unassigned">Unassigned</Select.Item>
            {users?.map((user) => (
              <Select.Item key={user.id} value={user.id}>
                {user.name}
              </Select.Item>
            ))}
          </Select.Group>
        </Select.Content>
      </Select.Root>
      <Toaster />
    </>
  );
};
```

NB: Before we forget remove x from "/xapi/users"

## Ch-8: Filtering, Sorting & Pagination

### 8.1 Building the filter component (IssueStatusFilter.tsx - List issue page)

Create filter component(IssueStatusFilter.tsx) and add this to IssueActions.tsx component

```jsx
// app/issues/list/IssueStatusFilter.tsx
"use client";
import { Status } from "@prisma/client";
import { Select } from "@radix-ui/themes";

// Here typescrip will guide you, so that you can not set wrong value
const statuses: { label: string, value?: Status }[] = [
  { label: "All" },
  { label: "Open", value: "OPEN" },
  { label: "In Progress", value: "IN_PROGRESS" },
  { label: "Closed", value: "CLOSED" },
];

const IssueStatusFilter = () => {
  return (
    <Select.Root>
      <Select.Trigger placeholder="Filter by status..." />
      <Select.Content>
        {statuses.map((status) => (
          <Select.Item key={status.value} value={status.value ?? "All"}>
            {status.label}
          </Select.Item>
        ))}
      </Select.Content>
    </Select.Root>
  );
};

// app/issues/list/IssueActions.tsx
return (
  <Flex mb="5" justify="between">
    <IssueStatusFilter />
    <Button>
      <Link href="/issues/new">New Issue</Link>
    </Button>
  </Flex>
);
```

### - 8.2 Filtering Issues

Pass value onChange, using useRouter(next/Nevigation), Then received it by searchParam of page.tsx and pass this value to Prisma

```jsx
// app/list/IssueStatusFilter.tsx
"use client";
import { Status } from "@prisma/client";

const IssueStatusFilter = () => {
  const router = useRouter(); // added

  return (
    <Select.Root // added
      onValueChange={(status) => {
        const url = status ? `?status=${status}` : "";
        router.push(url);
      }}
    >
      <Select.Trigger placeholder="Filter by status..." />
      <Select.Content>
        {statuses.map((status) => (
          <Select.Item key={status.value} value={status.value ?? "All"}>
            {status.label}
          </Select.Item>
        ))}
      </Select.Content>
    </Select.Root>
  );
};

// app/list/page.tsx
import { Status } from "@prisma/client";

interface Props {
  searchParams: { status: Status };
}

const IssuesPage = async ({ searchParams }: Props) => {
  console.log(searchParams.status); // Checking if it comming or not
  const statuses = Object.values(Status); // Getting values of an object
  const status =
    statuses.includes(searchParams.status)
      ? searchParams.status
      : undefined;

  const issues = await prisma.issue.findMany({
    where: { status },
  });

  return (

  );
};
```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```

### -

```jsx

```
